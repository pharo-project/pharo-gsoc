[
  {
    "id": "connect4MiniMax",
    "title": "Connect 4 game with AI",
    "img": "connect4.png",
    "supervisors": [
      "Sebastian Jordan"
    ],
    "description": "This project aims to develop a connect 4 game with an AI algorithm to play against humans. We will test the algorithm by playing humans vs. AI to see who wins. The first part will be building the GUI of the game using Bloc (https://github.com/pharo-graphics/bloc). Then, we will develop the AI algorithm that can play the game. The algorithm is alpha-beta-pruning (https://en.wikipedia.org/wiki/Alpha-beta_pruning)",
    "goal": "Build a connect 4 game with a graphical user interface that is playable. Develop the alpha-beta pruning AI algorithm to play the game against humans.",
    "keywords": [
      "AI",
      "game-theory",
      "Bloc",
      "games"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Communication skills",
        "OOP",
        "Pharo"
      ],
      "preferred": [
        "Basic AI knowledge"
      ]
    }
  },
  {
    "id": "serialization",
    "title": "Better Serialization Support",
    "img": "guille-serialization.jpeg",
    "supervisors": [
      "Guillermo Polito"
    ],
    "description": "This project aims at redesigning the textual and binary serialization support. Pharo has several textual serialization mechanisms (printOn, displayOn, storeOn, STON), and pickle binary format using Fuel.  Some of them are non-working or require a lot of manual work, and some of them are inefficient. Most of them repeat some code and can be replaced with another.",
    "goal": "- Replace the storeOn mechanism with STON literal serialization (see [pharo #3319](https://github.com/pharo-project/pharo/issues/3319))\n- Review the displayOn mechanism\n- Improve the printOn mechanism to not block on long print strings\n- Improve serialization of methods and block closures\n- Improve the performance of Fuel serialization with an improved identity hash table",
    "keywords": [
      "Serialization"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Refactoring",
        "OOP"
      ],
      "preferred": []
    }
  },
  {
    "id": "polymath-architecture",
    "title": "Improve the architecture of PolyMath",
    "img": "cyril-polymath.png",
    "supervisors": [
      "Oleksandr Zaitsev"
    ],
    "description": "PolyMath is a mathematical library in Pharo that implements various algorithms and data structure for algebra, matrix-vector operations, numerical analysis, differential equations, etc. It is similar to  NumPy and SciPy in Python or SciRuby in Ruby. \n\nThe goal of this project is to improve the overall quality of the PolyMath library in term of architecture and API. This includes improving the internal dependencies of PolyMath to make it more modular, proposing a more intuitive and unified API for the existing algorithms.\n\nStudents will also be encouraged to implement new algorithms for PolyMath or to create tutorials and blog posts for the existing ones. The PolyMath library has a very dynamic community so students will receive a lot of feedback and guidance to help them complete this project.",
    "goal": "- A more modular system\n- Cleaner dependencies\n- Improved API\n- Documentation\n- New algebra algorithms",
    "keywords": [
      "Math",
      "Algebra",
      "Infrastructure",
      "API"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo"
      ],
      "preferred": [
        "Be comfortable with math"
      ]
    }
  },
  {
    "id": "ui-builder",
    "title": "A Pharo User-Interface Builder",
    "img": "hernan-builder.jpg",
    "supervisors": [
      "Sebastian Jordan",
      "Nahuel Palumbo"
    ],
    "description": "Implement a designer application to develop graphical user interfaces (GUI) in Pharo. This will allow Pharo developers to build product functionality and focus on design instead of writing repetitive UI code and manually composing the UI layout. Widgets will be selected and dragged from a components tree, customized on a style pane, and the UI code will be generated. The tool will use Spec 2 (a framework in Pharo for describing user interfaces), and PCG (a Pharo Code Generator which allows AST manipulation). The emmited source code should be used to rebuild the user interface, including generation of event triggers, in the designer.",
    "goal": "The GUI designer will be able to recreate UI designs from generated code, for post-edition and re-generation.",
    "keywords": [
      "UI",
      "Design",
      "Builder"
    ],
    "size": "Large",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "Pharo",
        "AST"
      ],
      "preferred": [
        "Code Generation",
        "AST Manipulation"
      ]
    }
  },
  {
    "id": "eclipse-lsp",
    "title": "Eclipse-LSP in Pharo",
    "img": "nicolas-ide.png",
    "supervisors": [
      "Nicolas Anquetil",
      "Benoit Verhaeghe"
    ],
    "description": "The Language Server Protocol (LSP) defines the protocol used between an editor or IDE and a language server that provides language features like auto complete or rule violations (see picture). There is an initial implementation of LSP in Pharo. We are looking at making it work with the Eclipse SLP client plugin. This will involve straightening the existing SLP implementation (writing tests) and understand how Eclipse SLP plugin work.",
    "goal": "- A better SLP implementation in Pharo (more robust, with tests)\n- a better comprehension of how Eclipse SLP plugin works and what can be done with it",
    "keywords": [
      "Language Server Protocol",
      "Pharo",
      "Eclipse"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Meta Programming",
        "Eclipse Plugin"
      ],
      "preferred": [
        "Pharo"
      ]
    }
  },
  {
    "id": "ide-improvements",
    "title": "Improve IDE-UI features",
    "img": "guille-ide.jpeg",
    "supervisors": [
      "Guillermo Polito",
      "Nahuel Palumbo"
    ],
    "description": "Improve several IDE capabilities to improve UX for development, such as shortcut navigation, autocompletion features, menu options, and others present tools like dependency analyser.",
    "goal": "- Allow enabling\/disabling tools and shortcuts (see [pharo #2649](https://github.com/pharo-project/pharo/issues/2649))\n- Add autocompletion hooks (see Autocompletion hooks: [pharo #3177](https://github.com/pharo-project/pharo/issues/3177))\n- Enhance dependency analyser precision (see Dependency analyser precision: [pharo #3470](https://github.com/pharo-project/pharo/issues/3470)).",
    "keywords": [
      "IDE",
      "Tooling",
      "Autocompletion",
      "UI"
    ],
    "size": "Medium",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "Pharo",
        "OOP",
        "Code Analysis"
      ],
      "preferred": [
        "UI/UX"
      ]
    }
  },
  {
    "id": "code-text-improvements",
    "title": "Improve coding UX",
    "img": "palu-ide.jpeg",
    "supervisors": [
      "Gabriel Darbord",
      "Nahuel Palumbo"
    ],
    "description": "Improve the text editor capabilities for coding. It includes text drag n drop, better parenthesis support, and multiple selection.",
    "goal": "- Support multi-cursor/selection (see [pharo #17788](https://github.com/pharo-project/pharo/issues/17788))\n- Add text drag n drop support (see [pharo #2634](https://github.com/pharo-project/pharo/issues/2634))\n- Enhance parenthesis support (see [pharo #2635](https://github.com/pharo-project/pharo/issues/2635)).",
    "keywords": [
      "IDE",
      "Tooling",
      "Text Editor",
      "Coding"
    ],
    "size": "Medium",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "OOP",
        "Debugging",
        "Code Analysis"
      ],
      "preferred": [
        "UI/UX"
      ]
    }
  },
  {
    "id": "standard-library-api",
    "title": "Improve Standard Library APIs",
    "img": "guille-library.jpeg",
    "supervisors": [
      "Guillermo Polito",
      "Sebastian Jordan"
    ],
    "description": "The objective of this project is to improve the Pharo standard library.\nThis project includes low-level improvements in arithmetics, color APIs and collections.\nSuch changes will be backed up by benchmarks to show no performance improvements are introduced.",
    "goal": "We expect at least fixes in the following aras:\n- Collections should use better default sorting algorithms (see [pharo #2866](https://github.com/pharo-project/pharo/issues/2866))\n- Improve Color API (see [pharo #3264](https://github.com/pharo-project/pharo/issues/3264))\n- Speeding up arithmetics (see [pharo #3322](https://github.com/pharo-project/pharo/issues/3322))\n- Redesign Collection cancelled methods (see [pharo #4113](https://github.com/pharo-project/pharo/issues/4113))",
    "keywords": [
      "Redesign",
      "Optimisation",
      "Standard Library"
    ],
    "size": "Medium",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "OOP",
        "Refactoring"
      ],
      "preferred": []
    }
  },
  {
    "id": "data-structures-and-algorithms",
    "title": "Implementation of standard data structures and algorithms",
    "img": "gordana-trees.png",
    "supervisors": [
      "Gordana Rakic",
      "Stephane Ducasse"
    ],
    "description": "Support for data structures such as various kinds of lists and trees are weakly supported in Pharo, while the ones that are implemented are not wel designed which makes maintenance and extensions more difficult. A nice data structures design with a stable and reflective API together with corresponding algorithms implementation are the main task in this project idea.",
    "goal": "The main goal is to create a flexible and extensible data structures design and to implement at least some of basic lists such as (double-)linked lists, a heap, a stack, a buffer, and some of basic trees e.g. a binary tree, a binary search tree, a self-balancing tree, an AVL, a red-black, or a B-tree.",
    "keywords": [
      "Design",
      "API",
      "Data Structures"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Data structures and algorithms"
      ],
      "preferred": []
    }
  },
  {
    "id": "system-and-security",
    "title": "System and Security Improvements",
    "img": "guille-security.jpeg",
    "supervisors": [
      "Guillermo Polito"
    ],
    "description": "The objective of the project is to improve system integration in standard libraries.\nFor example, the system's locale support could be improved to access the system's language, text encoding, number and date formatting. Similar improvements could be brought to sockets, zip files, downloads.",
    "goal": "We expect to solve the following issues:\n- Checksums of downloads: [pharo #3391](https://github.com/pharo-project/pharo/issues/3391)\n- Locale redesign: [pharo #3844](https://github.com/pharo-project/pharo/issues/3844)\n- Unix sockets: [pharo #4046](https://github.com/pharo-project/pharo/issues/4046)\n- Bootstrap improvements: [pharo #4269](https://github.com/pharo-project/pharo/issues/4269)",
    "keywords": [
      "System Integration",
      "Low-level"
    ],
    "size": "Large",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "Encodings",
        "Foreign Function Interface"
      ],
      "preferred": [
        "OOP"
      ]
    }
  },
  {
    "id": "druid-optimisation",
    "title": "Optimisations for a Meta-Compiler",
    "img": "nahue-druid.png",
    "supervisors": [
      "Nahuel Palumbo",
      "Guillermo Polito"
    ],
    "description": "This project has the objective of improving the optimisation capabilities of the Druid meta-compiler. Druid is a meta-compiler that generates Just-In-Time Compiler code from an Interpreter definition. It performs an abstract meta-interpretation to generate an SSA-based Intermediate Representation (IR); this IR is optimised and used to generate machine code. With Druid, language implementors can define their interpreters and generate a JIT Compiler from them.",
    "goal": "Implement some optimisation over Druid's IR, such as Dead Store Elimination, Class Hierarchy Analysis, and Arithmetic Operations Transformation. It is possible also to improve any already implemented optimisations such as Inline, Global Value Numbering, Loop Invariant Code Motion, etc.",
    "keywords": [
      "Optimisation",
      "SSA",
      "Compilation"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP"
      ],
      "preferred": [
        "Compilers"
      ]
    }
  },
  {
    "id": "pharo-optimisation",
    "title": "Optimising Pharo Compiler",
    "img": "nahue-opt-pharo.png",
    "supervisors": [
      "Nahuel Palumbo",
      "Pablo Tesone"
    ],
    "description": "This is an experiment to inline Pharo methods at the bytecode level. The idea is to collect information about the methods that are called for some message sends and recompile the sender method inlining the callees. The main goal is to reduce the number of method calls in the VM and improve performance.",
    "goal": "Generate optimised bytecode for Collection's methods. It means developing a type system to collect the type info from PICs, and recompile the methods with an optimising compiler (WIP). We also want to measure the performance of this strategy.",
    "keywords": [
      "Optimisation",
      "Inline",
      "Compilation"
    ],
    "size": "Large",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "OOP"
      ],
      "preferred": [
        "Compilers"
      ]
    }
  },
  {
    "id": "spatial-data",
    "title": "Classes and Methods for Spatial Data manipulation",
    "img": "etienne-gis.jpg",
    "supervisors": [
      "Etienne Delay"
    ],
    "description": "We propose to explore structure to spatial data finding a way to handle different types of geospatial data in pharo. Once the data is manipulable with our tools the goal is to develop some spatial method allowing for users to deal with spatial data. For that we will start from tools already existing in pharo like the packages : geometry, shapes, geo-json and territorial, but also in other programming languages (as r or python) in order to implement spatial methods for the community. The main objective will be first to be able to load a geojson file, to visualize it and to basic geometric operations.",
    "goal": "DSL compatible with OGS standar for spatial data manipulation",
    "keywords": [
      "Simple Feature",
      "GIS",
      "Spatial"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo"
      ],
      "preferred": [
        "GIS"
      ]
    }
  },
  {
    "id": "microdown-blog",
    "title": "A lightweigth Microdown-based Blog engine",
    "img": "stef-blog.jpeg",
    "supervisors": [
      "Stephane Ducasse"
    ],
    "description": "With Pharo 11, Microdown is now used to write books, slides, render class comments, render documentation. It is becoming a central piece for Pharo documents and documentations. The next step is to support the definition of blog. This way Pharo will be able to navigate and display another important source of information within Pharo: its own blogs. The astute reader may wonder why not using other systems for building blog because we have to have the full control on a simple blog engine that we can just deploy with Pharo. ",
    "goal": "The student will:\n- study microdown, its visitors\n- study the export to HTML \n- build some logic to summarise a blog post, a monthly sorting of blog post, a full post display\n\nWe will test this blog engine on the [Pharo Weekly blog](https://pharoweekly.wordpress.com/)\nIn a second iteration a search component will be developed.",
    "keywords": [
      "Microdown",
      "HTML",
      "Blog"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo",
        "Communication skills"
      ],
      "preferred": []
    }
  },
  {
    "id": "data-frame",
    "title": "DataFrame",
    "img": "dataframe.png",
    "supervisors": [
      "Oleksandr Zaitsev",
      "Serge Stinckwich"
    ],
    "description": "DataFrame was introduced to Pharo during the GSoC 2017 (https://github.com/PolyMathOrg/DataFrame). The work on DataFrame continued and many new features were introduced by different contributors. However, it is still a work in progress and a huge portion of functionality that can be found in other data frame packages (e.g. R, pandas) is missing.",
    "goal": "The goal of this project is to introduce new functionality to DataFrame and write examples of applying DataFrame to real problems of Data Science (one can reproduce examples from pandas and scikit-learn documentation, as well as some examples from R-bloggers)",
    "keywords": [
      "data science",
      "data analysis",
      "dataframe",
      "tabular data",
      "statistics"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo",
        "Communication skills"
      ],
      "preferred": []
    }
  },
  {
    "id": "dr-tests",
    "title": "DrTests",
    "img": "drtests.jpeg",
    "supervisors": [
      "Stephane Ducasse",
      "Sebastian Jordan"
    ],
    "description": "DrTests is a Pharo tool that we use to run several tests cases at once.\nIt is very useful when developping because we have the power to run a selected scope of tests from different packages to control the situation of the tests.",
    "goal": "The goal is to improve DrTests, add more features to have a new version to it that will be the default Test Runner of Pharo.",
    "keywords": [
      "unit tests",
      "tools",
      "test runner"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo",
        "Communication skills"
      ],
      "preferred": []
    }
  },
  {
    "id": "pca-methods",
    "title": "PCA Methods",
    "img": "pca.png",
    "supervisors": [
      "Oleksandr Zaitsev"
    ],
    "description": "Write an object-model in Pharo to provide Principal Component Analysis (PCA) variants such as Sparse PCA, Randomized PCA, Incremental PCA and Kernel PCA (Centering).\nThe PolyMath library already provides an implementation of PCA which could be used as basis for extending with.",
    "goal": "Having a solid library for doing principal component analysis",
    "keywords": [
      "pca",
      "sva",
      "dimensionality reduction"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo",
        "Communication skills"
      ],
      "preferred": []
    }
  },
  {
    "id": "tensor-flow-plugin",
    "title": "TensorFlow Plugin",
    "img": "tensorflow.png",
    "supervisors": [
      "Sebastian Sastre",
      "Sebastian Jordan"
    ],
    "description": "Lets make a TensoFlow plugin (not FFI) for Pharo and unblock Pharo AI possibilities by putting it among the ones at the top of the AI pyramid! It will be C TensoFlow used by C our plugin by our C VM using the GPU silicon at its fullest. A path to mine GPU power in the most efficient way in the Smalltalk friendly and powerful way. No other bridges needed. Then all the algebra and AI Smalltalk libraries would be able to use TensoFlow like a boss.",
    "goal": "All the primitives to the TensorFlow API having at least 1 unit test for quality assurance would be the definition of done.",
    "keywords": [
      "Artificial Intelligence",
      "TensorFlow",
      "Machine Learning",
      "GPU"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Basic C",
        "Familiarity with how the Pharo VM is created",
        "Familiarity with Slang",
        "Communication skills"
      ],
      "preferred": [
        "Having done a Pharo plugin"
      ]
    }
  },
  {
    "id": "VirtualIoTDevices",
    "title": "Virtual Devices for PharoThings",
    "img": "gordana-iot.jpg",
    "supervisors": [
      "Oleksandr Zaitsev",
      "Gordana Rakic"
    ],
    "description": "PharoThings implements communication with a connected physical hardware or with a remote one through TelePharo when the local hardware is not available. This makes PharoThings strongly dependent on physical hardware. Elimination of this dependency might be very useful  for learning and testing purposes, while it is possible by simulation of hardware response by random actions of virtual objects playing hardware roles.",
    "goal": "Design and implement solution that provides higher availability of remote devices through TelePharo by inclusion of virtual devises when physical ones are not present.",
    "keywords": [
      "IoT",
      "TelePharo",
      "PharoThings"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "IoT",
        "Communication skills"
      ],
      "preferred": [
        "PharoThings",
        "TelePharo"
      ]
    }
  },
  {
    "id": "ffi",
    "title": "Accelerate FFI calls through JIT compilation",
    "img": "guille-ffi.jpg",
    "supervisors": [
      "Guillermo Polito"
    ],
    "description": "This project aims at adding JIT compiler support for common FFI calls, to accelerate calls and marshalling",
    "goal": "Profile FFI libraries to know what are the most used FFI call signatures; Refactor the cogit JIT compiler to detect FFI callout code; Introduce backend specific code for common call signatures in x86-64 and ARM64",
    "keywords": [
      "compilation",
      "jit compilation",
      "library integration",
      "ffi"
    ],
    "size": "Medium",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "compilers",
        "OOP",
        "assembly"
      ],
      "preferred": []
    }
  },
  {
    "id": "CFGInTesting",
    "title": "Using CFG to analyze tests",
    "img": "gordana-cfg.jpg",
    "supervisors": [
      "Pablo Tesone",
      "Gordana Rakic"
    ],
    "description": "To produce an initial model that represents the Control-Graph-Flow (CFG) of an Pharo application, including application tests, we need to perform an static analysis on the program. The analysis of the program is done traversing Abstract Syntax Tree (AST) of the methods, and class definitions. Pharo provides a set of existent tools to manipulate and traverse ASTs, and reflective tools to inspect programs in Pharo. Also, there are implementations of required tools to be used or extended (AST interpreters, CFG extraction tools, type inferers (Phineas), etc). This task can be divided in three main points: (1) developing the CFG model, (2) extract the information from the Pharo AST, (3) perform traversal and analyses over it. For extracting the information in the AST and form the CGF, the student should use tools already existent in Pharo (AST interpreters/Type inferer). Finally, it can be possible to perform an analysis on the existing information. For example, it is possible to extract the effective classes and methods that are covered by a given test; or calculate the dependencies between classes and methods. This topic provides an oportunity of working on the meta-level of programs, while the student will learn how to get information from an existing program, and how to reflect about it. These tools and abilities are basic when working with programming languages, refactorings, tools, etc.",
    "goal": "Create the CFG model and design and implement solution that traverses the AST and builds the CFG extracts the information from the Pharo AST, performs traversal and analyses over it, orimarily analysis of tests.",
    "keywords": [
      "Abstract Syntax Tree (AST)",
      "Control-Flow Graph (CFG)",
      "Static Analysis",
      "Software Testing"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "Communication skills"
      ],
      "preferred": [
        "Testing",
        "Type Inference"
      ]
    }
  },
  {
    "id": "MOP",
    "title": "Meta-Object Protocol for Object-Centric Debugging Tools Implementation",
    "img": "",
    "supervisors": [
      "Steven Costiou",
      "Valentin Bourcier"
    ],
    "description": "In this project, the student will start for a MOP prototype, improve the MOP design, extend it, test it, and apply it to the implementation of object-centric debuggers.",
    "goal": "Design and implement a meta-object protocol for building object-centric debugging tools.",
    "keywords": [
      "Object-Centric Debugging",
      "Reflection"
    ],
    "size": "Medium",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "OOP",
        "Debugging",
        "Reflection",
        "Communication skills"
      ],
      "preferred": [
        "Reflection"
      ]
    }
  },
  {
    "id": "FaultLocation",
    "title": "Fault Location DrTest Plugin",
    "img": "fault-location.jpg",
    "supervisors": [
      "Juan Pablo Sandoval",
      "Geraldine Galindo",
      "Kevin Cespedez"
    ],
    "description": "In this project, the student will implement two or three different fault location algorithms, for this, it will also be necessary to implement a matrix coverage. Then we will integrate the fault location algorithms in the DrTest UI tool, and of course to Pharo itself.",
    "goal": "The goal is implement a plugin for DrTest that implements two or three fault location state-of-the-art algorithms.",
    "keywords": [
      "Fault Location",
      "DrTest",
      "Dynamic Analysis",
      "Software Testing"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "Communication skills"
      ],
      "preferred": [
        "Testing",
        "Dynamic Analysis"
      ]
    }
  },
  {
    "id": "LLMInterface",
    "title": "A Seamless interface between LLMs and Pharo",
    "img": "PharoLLMsInterface.png",
    "supervisors": [
      "Balša Šarenac"
    ],
    "description": "This project aims to create an intuitive interface between Pharo and large language models (LLMs). By integrating Pharo with LLMs, developers can leverage AI-powered assistance, automation, and natural language processing (NLP) while maintaining Pharo’s unique live programming environment. Perfect project to get familiar with Pharo and different development techniques while enabling its users to experience LLMs in one of the best live environments!",
    "goal": "The goal is to implement native UI interface that will interact with various LLM providers. Users should be able to chat with chosen type of LLM, and create custom actions that will send code to LLMs to make modifications on them.",
    "keywords": [
      "AI",
      "LLM",
      "UI",
      "IDE",
      "Code improvements"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Communication skills"
      ],
      "preferred": [
        "AI",
        "Pharo"
      ]
    }
  },
  {
    "id": "PharoRefactoringEngine",
    "title": "Enhancing Pharo’s Refactoring Engine for a Smarter Development Experience",
    "img": "PharoRefactoringEngine.png",
    "supervisors": [
      "Balša Šarenac"
    ],
    "description": "One of its key strengths is its powerful development environment, which includes an advanced refactoring engine. Originally pioneered in Smalltalk, the refactoring engine plays a crucial role in maintaining code quality, improving design, and enhancing developer productivity. This proposal aims to improve Pharo’s refactoring engine by addressing usability, migrating to modern tools, and extending its capabilities with additional refactorings. By refining the refactoring workflow, this project will ensure a smoother experience for developers while keeping Pharo’s tooling at the forefront of modern software engineering practices. Ideal project to learn a lot about Pharo, ASTs, desgin, refactorings, software engineering in general!",
    "goal": "The goals include: streamlining user experience, migration to new tools and architecture, analysis and implementation of existing refactorings and improved testing.",
    "keywords": [
      "Refactoring Engine",
      "Design",
      "UX",
      "Software engineering",
      "Architecture"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "Debugging",
        "Communication skills"
      ],
      "preferred": [
        "Testing",
        "Reflection"
      ]
    }
  },
  {
    "id": "game-tiles",
    "title": "Adding Game Tiles and Sprites to Cormas",
    "img": "game-tiles.png",
    "supervisors": [
      "Milton Mamani Torres",
      "Oleksandr Zaitsev"
    ],
    "description": "The current version of Cormas allows us to visualize the space and agents in the simulation using colors and geometric shapes (circles, rectangles, etc.). In this project, we want to add support for custom tilesets like the ones that are used in computer games. This would allow us to greatly improve the visual capabilities of Cormas by using custom pixel art. In Pharo, we already have support for sprites, which means that we know how to implement this project technically and can guide GSoC contributor in this. This project will require a lot of creativity because we expect contributor to propos a nice API and to build a collection of game tiles that can be used in Cormas.",
    "goal": "- Add support for pixel art tilesets to Cormas\n- Propose a collection of default tiles and the methods for loading custom ones\n- Propose an API for configuring Cormas model to use a given tileset\n- Implement some of our existing models with tiles, and demonstrate them through videos and blog posts",
    "keywords": [
      "Visualization",
      "Agent-base modelling",
      "Games",
      "Tilesets",
      "Sprites",
      "Pixel art"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo",
        "Object-oriented programming"
      ],
      "preferred": [
        "Visualization",
        "Art",
        "Gaming"
      ]
    }
  },
  {
    "id": "sound-effects",
    "title": "Sound Effect Library for Agent-Based Simulations",
    "img": "domenico-sound.jpeg",
    "supervisors": [
      "Domenico Cipriani",
      "Oleksandr Zaitsev"
    ],
    "description": "In Pharo, there is a library for generating and synthesizing music. We want to use it to add sound effects to Cormas simulations. It will start with simple sound effects, for example, when a cow says Mooo or when walking of a grass makes a sound. Then we will explore to which extent a simulation can be perceived through sound. Can different scenarios (high energy / low energy) sound differntly? Can sounds help us understand simulations better? This is an innovative project that can have an important impact in the field participatory simulations by making our tools more accessible and more intuitive for people with disabilities and for the local stakeholders who do not have a technical background.",
    "goal": "- Create simple sound effects in Pharo and release them as a library\n- Assign those sound effects to actions and events in Cormas simulations\n- Build an API for manipulating sounds in Cormas\n- Explore the patterns that emerge is a simulation through sound effects",
    "keywords": [
      "Music",
      "Agent-base modelling",
      "Sound"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo",
        "Object-oriented programming"
      ],
      "preferred": [
        "Cormas",
        "C"
      ]
    }
  },
  {
    "id": "moose-cormas",
    "title": "Analysing Cormas Code with Moose",
    "img": "nicolas-moose.png",
    "supervisors": [
      "Nicolas Anquetil",
      "Oleksandr Zaitsev"
    ],
    "description": "[Moose](https://moosetechnology.org/) is a platform for software and data analysis implemented in Pharo. It provides an extensive toolkit for exploring the source code of a given project, find code defects, bad practices, etc. Cormas is a legacy software system that has been in development for more than 25 years. It has been migrated from one dialect of Smalltalk to another, it has been maintained by different people with different levels of expertise and different programming practices. As such, Cormas is a very interesting case study for code analysis. Using Moose, we can detect dead code (methods that are no longer used), split god classes and methods (the ones that are clearly too large), reorganize packages to reduce coupling, improve test coverage. All this information can be extremely valuable for Cormas development and it can also contribute to the improvement of Moose platform.",
    "goal": "- Learn to use Moose (we have detailed guides and tutorials)\n- Load the source code of Cormas into Moose\n- Perform various analyses and build visualizations\n- Report the findings to the Cormas community\n- Improve the source code of Cormas",
    "keywords": [
      "Code analysis",
      "Code comprehension",
      "Visualizations",
      "Programming"
    ],
    "size": "Medium",
    "difficulty": "Easy",
    "skills": {
      "required": [
        "Pharo",
        "Object-oriented programming"
      ],
      "preferred": [
        "Cormas",
        "Moose"
      ]
    }
  },
  {
    "id": "object-detection",
    "title": "Computer Vision for Game Piece Detection",
    "img": "computer-vision.png",
    "supervisors": [
      "Etienne Delay",
      "Oleksandr Zaitsev"
    ],
    "description": "The goal of this project is to enhance the interactive functionality of Cormas by building a computer vision system for detecting tangible objects such as board game pieces. Such a system would permit people to play a [serious game](https://en.wikipedia.org/wiki/Serious_game) on a physical board and have a camera detect the movement of pieces and automatically update the Cormas model. The game could then be stored, replayed, interacted with, and analysed using Cormas.\n\nObject detection can be implemented based on the smartphone camera or with a more advanced dedicated tool such as [Azure Kinect](https://azure.microsoft.com/en-us/products/kinect-dk/). Adaptation of Cormas platform for receiving live input from real world is a very important aspect of this project.",
    "goal": "- Implement and test the API in Cormas for positioning agents on the spatial grid\n- Implement a prototype of an object detection system using computer vision\n- Connect the implemented object detection system to Cormas\n- Implement calibration and board initialization",
    "keywords": [
      "Computer Vision",
      "Machine Learning",
      "AI",
      "Agent-Based Modeling"
    ],
    "size": "Large",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "Machine Learing",
        "Computer Vision"
      ],
      "preferred": [
        "Pharo",
        "Python",
        "PyTorch",
        "YOLO",
        "Open CV"
      ]
    }
  },
  {
    "id": "hexagonal-cells",
    "title": "Adding Hexagonal Cells to Cormas Pharo",
    "img": "hexagonal-cells.png",
    "supervisors": [
      "Milton Mamani Torres",
      "Oleksandr Zaitsev"
    ],
    "description": "In VisualWorks version of Cormas, we had a good support for hexagonal cells. In the current version of Cormas that we have in Pharo, we can only use square cells. The goal of this project is therefore to (re-)implement the hexagonal grid. The contribution of this project can also be submitted to [Roassal3](https://github.com/pharo-graphics/Roassal) visualization library. We would like to take inspiration from this article: [Hexagonal Grids from Red Blob Games](https://www.redblobgames.com/grids/hexagons/) to implement the hexagonal geometry in Roassal and use it to enhance the spatial model of Cormas.",
    "goal": "- Implement hexagonal grid layout in Roassal based on the article cited above\n- Use hexagonal layout to add hexagonal cells to the spatial model of Cormas\n- Experiemnt with the possibility of dynamically switching between square and hexagonal grids in the simulation\n- Experiment with other types of grids, for example, triangular",
    "keywords": [
      "Computer Graphics",
      "Geometry",
      "Grids",
      "Hexagonal Cells"
    ],
    "size": "Large",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "Pharo",
        "Object-Oriented Programming"
      ],
      "preferred": [
        "Computer Graphics",
        "Geometry",
        "Roassal"
      ]
    }
  }
]
