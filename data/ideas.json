[
  {
    "id": "GenericAST4Moose",
    "title": "A generic AST for Moose",
    "img": "Moose.jpg",
    "supervisors": [
      "Nicolas Anquetil"
    ],
    "description": "The idea is to define a generic meta-model for ASTs",
    "goal": "The ![moose platform](https://modularmoose.org) uses meta-models to represent programs. FAST (Famix-AST) is the familly of meta-models for AST in Moose. It represents the source code with a very fine level of details. Currently Moose as FAST  meta-models for Java, Fortran-77, Fortran-2008, and Pharo. There is ongoing work for TypeScript and Python. The goal of the project is to define generic AST concepts that will allow to easily create new langage specific AST meta-models that would work with all Moose tools.",
    "keywords": [
      "Moose",
      "meta-models",
      "AST",
      "FAMIX",
      "Static analysis"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Communication skills",
        "OOP",
        "Pharo"
      ],
      "preferred": [
        "Visitor, Builder, and other patterns",
        "OO Design"
      ]
    }
  },
  {
    "id": "dockerScratchDeployments",
    "title": "Pharo VM running as Docker Scratch image",
    "img": "dockervm.png",
    "supervisors": [
      "Tim Mackinnon"
    ],
    "description": "This project aims to enable an efficient deployment mechanism for Pharo applications, where they run in a Docker scratch (layer 0) image without any operating system dependency or overhead. Being able to run pharo in an efficient docker image simplifies deployment particularly in the web space where docker images are becoming a defacto standard. Pharo is quite unique as its possible to run without any file io dependencies in a self contained manner that matches scratch image requirements. The smaller size of a scratch image also means improved resource management and also reduces secuirty risks inherent with operating system overhead that isn't needed for many classes of pharo application, particularly web based ones. The student will need to study the hello world docker scratch example and then figure out how to statically compile the vm, necessary plugins and image so that no dynamic operating system dependencies are needed for execution.",
    "goal": "Have a pharo vm+image run in a docker scratch image where there is no operating system dependency or overhead",
    "keywords": [
      "docker",
      "deployment",
      "security"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Docker",
        "VM",
        "CI/CD",
        "C",
        "Pharo"
      ],
      "preferred": [
        "Web Applications"
      ]
    }
  },
  {
    "id": "data-structures-and-algorithms",
    "title": "Algorithms, data structures and graphs",
    "img": "gordana-trees.png",
    "supervisors": [
      "Sebastian Jordan",
      "Gordana Rakic",
      "Stéphane Ducasse"
    ],
    "description": "Pharo has a vast implementationg of data structures such as various kinds of lists, trees and graphs. It also has a vast collection of graph algorithms, pattern matching algorithms, string matching, and others. The idea of this project is to improve the data structures and algorithms by adding new ones or optimizing the current ones. The project can take several directions, depending on the student's interests. For more information check or implementations on GitHub. github.com/pharo-ai/graph-algorithms https://github.com/pharo-containers https://github.com/pharo-ai/ ",
    "goal": "The main goal is to create solid data structures and algorithms. The implementations should always be benchmarked to measure the performance and of course it must have sounding tests.",
    "keywords": [
      "Data Structures",
      "Algorithms",
      "Graphs",
      "Machine learning"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Data structures and algorithms"
      ],
      "preferred": []
    }
  },
  {
    "id": "druid-optimisation",
    "title": "Compiler Optimizations in SSA form",
    "img": "nahue-druid.png",
    "supervisors": [
      "Nahuel Palumbo",
      "Guillermo Polito"
    ],
    "description": "Druid is a metacompiler to generate a Just-In-Time Compiler in the Pharo VM. With Druid, language implementors can define their interpreters and generate a JIT Compiler from them. It uses an SSA-based Intermediate Representation (IR) to apply optimizations.",
    "goal": "Implement some optimisation over Druid's IR, such as Dead Store Elimination, Class Hierarchy Analysis, and Arithmetic Operations Transformation. It is possible also to improve any already implemented optimisations such as Inline, Global Value Numbering, Loop Invariant Code Motion, etc.",
    "keywords": [
      "Optimisation",
      "SSA",
      "Compilation"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP"
      ],
      "preferred": [
        "Compilers"
      ]
    }
  },
  {
    "id": "pharo-optimisation",
    "title": "Optimizing the Pharo Compiler at Bytecode-Level",
    "img": "nahue-opt-pharo.png",
    "supervisors": [
      "Nahuel Palumbo",
      "Pablo Tesone"
    ],
    "description": "This project explores the implementation of an optimizing compiler for Pharo bytecode. It uses the Druid's SSA-based intermediate representation to apply optimizations and generate efficient bytecode from source code. These optimizations involve inlinings, constant folding, dead code eliminations, etc. We want to improve already implemented optimizations, such as improve the heuristics to guide inlinings, as well as implement new specific ones, eg. optimize access variables from outer contexts. By reducing the work of the VM, we aim to enhance execution speed of executed programs.",
    "goal": "- Developing a type system to guide the inlining of message sends.\n- Optimize access to outer context variables.\n- Develop a recompilation strategy to move to production.\n\nThis experiment seeks to refine Pharo’s compilation strategy, leveraging method inlining for better performance while maintaining flexibility in dynamic code updates.",
    "keywords": [
      "Optimisation",
      "Inline",
      "Compilation"
    ],
    "size": "Large",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "OOP"
      ],
      "preferred": [
        "Compilers"
      ]
    }
  },
  {
    "id": "VirtualIoTDevices",
    "title": "Virtual Devices for PharoThings",
    "img": "gordana-iot.jpg",
    "supervisors": [
      "Oleksandr Zaitsev",
      "Gordana Rakic"
    ],
    "description": "PharoThings implements communication with a connected physical hardware or with a remote one through TelePharo when the local hardware is not available. This makes PharoThings strongly dependent on physical hardware. Elimination of this dependency might be very useful  for learning and testing purposes, while it is possible by simulation of hardware response by random actions of virtual objects playing hardware roles.",
    "goal": "Design and implement solution that provides higher availability of remote devices through TelePharo by inclusion of virtual devises when physical ones are not present.",
    "keywords": [
      "IoT",
      "TelePharo",
      "PharoThings"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "IoT",
        "Communication skills"
      ],
      "preferred": [
        "PharoThings",
        "TelePharo"
      ]
    }
  },
  {
    "id": "CFGInTesting",
    "title": "Using CFG to analyze tests",
    "img": "gordana-cfg.jpg",
    "supervisors": [
      "Pablo Tesone",
      "Gordana Rakic"
    ],
    "description": "To produce an initial model that represents the Control-Graph-Flow (CFG) of an Pharo application, including application tests, we need to perform an static analysis on the program. The analysis of the program is done traversing Abstract Syntax Tree (AST) of the methods, and class definitions. Pharo provides a set of existent tools to manipulate and traverse ASTs, and reflective tools to inspect programs in Pharo. Also, there are implementations of required tools to be used or extended (AST interpreters, CFG extraction tools, type inferers (Phineas), etc). This task can be divided in three main points: (1) developing the CFG model, (2) extract the information from the Pharo AST, (3) perform traversal and analyses over it. For extracting the information in the AST and form the CGF, the student should use tools already existent in Pharo (AST interpreters/Type inferer). Finally, it can be possible to perform an analysis on the existing information. For example, it is possible to extract the effective classes and methods that are covered by a given test; or calculate the dependencies between classes and methods. This topic provides an oportunity of working on the meta-level of programs, while the student will learn how to get information from an existing program, and how to reflect about it. These tools and abilities are basic when working with programming languages, refactorings, tools, etc.",
    "goal": "Create the CFG model and design and implement solution that traverses the AST and builds the CFG extracts the information from the Pharo AST, performs traversal and analyses over it, orimarily analysis of tests.",
    "keywords": [
      "Abstract Syntax Tree (AST)",
      "Control-Flow Graph (CFG)",
      "Static Analysis",
      "Software Testing"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "Communication skills"
      ],
      "preferred": [
        "Testing",
        "Type Inference"
      ]
    }
  },
  {
    "id": "MOP",
    "title": "Meta-Object Protocol for Object-Centric Debugging Tools Implementation",
    "img": "",
    "supervisors": [
      "Steven Costiou",
      "Valentin Bourcier"
    ],
    "description": "In this project, the student will start for a MOP prototype, improve the MOP design, extend it, test it, and apply it to the implementation of object-centric debuggers.",
    "goal": "Design and implement a meta-object protocol for building object-centric debugging tools.",
    "keywords": [
      "Object-Centric Debugging",
      "Reflection"
    ],
    "size": "Medium",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "OOP",
        "Debugging",
        "Reflection",
        "Communication skills"
      ],
      "preferred": [
        "Reflection"
      ]
    }
  },
  {
    "id": "FaultLocation",
    "title": "Fault Location DrTest Plugin",
    "img": "fault-location.jpg",
    "supervisors": [
      "Juan Pablo Sandoval"
    ],
    "description": "In this project, the student will implement two or three different fault location algorithms, for this, it will also be necessary to implement a matrix coverage. Then we will integrate the fault location algorithms in the DrTest UI tool, and of course to Pharo itself.",
    "goal": "The goal is implement a plugin for DrTest that implements two or three fault location state-of-the-art algorithms.",
    "keywords": [
      "Fault Location",
      "DrTest",
      "Dynamic Analysis",
      "Software Testing"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "Communication skills"
      ],
      "preferred": [
        "Testing",
        "Dynamic Analysis"
      ]
    }
  },
  {
    "id": "ChatPharo",
    "title": "ChatPharo: Bringing LLMs to Live Programming",
    "img": "PharoLLMsInterface.png",
    "supervisors": [
      "Omar AbedelKader"
    ],
    "description": "This project focuses on improving and extending an existing interface between Pharo and large language models (LLMs). The current integration already allows interaction with LLMs within Pharo’s live programming environment; the proposed work aims to refine the interface, enhance usability, expand functionality, and improve developer workflows. By building on this foundation, developers can better leverage AI-powered assistance, automation, and natural language interaction while preserving Pharo’s unique live programming experience. Documentation: https://omarabedelkader.github.io/ChatPharo/.",
    "goal": "The goal is to enhance the native UI interface that interacts with various LLM providers. Users should be able to chat with selected LLMs more effectively and define custom actions that send code to LLMs for analysis, transformation, or modification.",
    "keywords": [
      "AI",
      "LLM",
      "UI",
      "IDE",
      "Code improvements"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Communication skills",
        "AI"
      ],
      "preferred": [
        "AI",
        "Pharo"
      ]
    }
  },
  {
    "id": "PharoRefactoringEngine",
    "title": "Enhancing Pharo’s Refactoring Engine for a Smarter Development Experience",
    "img": "PharoRefactoringEngine.png",
    "supervisors": [
      "Balša Šarenac",
      "Stéphane Ducasse",
      "Juan Pablo Sandoval"
    ],
    "description": "One of its key strengths is its powerful development environment, which includes an advanced refactoring engine. Originally pioneered in Smalltalk, the refactoring engine plays a crucial role in maintaining code quality, improving design, and enhancing developer productivity. This proposal aims to improve Pharo’s refactoring engine by addressing usability, migrating to modern tools, and extending its capabilities with additional refactorings. By refining the refactoring workflow, this project will ensure a smoother experience for developers while keeping Pharo’s tooling at the forefront of modern software engineering practices. Ideal project to learn a lot about Pharo, ASTs, desgin, refactorings, software engineering in general!",
    "goal": "The goals include: streamlining user experience, migration to new tools and architecture, analysis and implementation of existing refactorings and improved testing.",
    "keywords": [
      "Refactoring Engine",
      "Design",
      "UX",
      "Software engineering",
      "Architecture"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "OOP",
        "Pharo",
        "Debugging",
        "Communication skills"
      ],
      "preferred": [
        "Testing",
        "Reflection"
      ]
    }
  },
  {
    "id": "game-tiles",
    "title": "Adding Game Tiles and Sprites to Cormas",
    "img": "game-tiles.png",
    "supervisors": [
      "Milton Mamani Torres",
      "Oleksandr Zaitsev"
    ],
    "description": "The current version of Cormas allows us to visualize the space and agents in the simulation using colors and geometric shapes (circles, rectangles, etc.). In this project, we want to add support for custom tilesets like the ones that are used in computer games. This would allow us to greatly improve the visual capabilities of Cormas by using custom pixel art. In Pharo, we already have support for sprites, which means that we know how to implement this project technically and can guide GSoC contributor in this. This project will require a lot of creativity because we expect contributor to propos a nice API and to build a collection of game tiles that can be used in Cormas.",
    "goal": "- Add support for pixel art tilesets to Cormas\n- Propose a collection of default tiles and the methods for loading custom ones\n- Propose an API for configuring Cormas model to use a given tileset\n- Implement some of our existing models with tiles, and demonstrate them through videos and blog posts",
    "keywords": [
      "Visualization",
      "Agent-base modelling",
      "Games",
      "Tilesets",
      "Sprites",
      "Pixel art"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo",
        "Object-oriented programming"
      ],
      "preferred": [
        "Visualization",
        "Art",
        "Gaming"
      ]
    }
  },
  {
    "id": "fiber",
    "title": "Improve the Green threads / Fiber",
    "img": "guille-fiber.png",
    "supervisors": [
      "Guillermo Polito",
      "Pablo Tesone"
    ],
    "description": "Pharo currently implements Green Threads / Fiber through the Process class. However, certain edge cases exhibit undefined behavior. This project aims to thoroughly test these cases, document the current implementation, identify potential bugs, and work towards fixing them to ensure a more robust and reliable concurrency model.",
    "goal": "Improve the implementation of Green threads / Fiber in Pharo:\n- Find and test border cases\n- Find bugs and fix them.",
    "keywords": [
      "green thread",
      "fiber"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Refactoring",
        "OOP"
      ],
      "preferred": []
    }
  },
  {
    "id": "reg-aloc-jit",
    "title": "Enhance Register Allocation at Control Flow Merge Points During JIT Compilation",
    "img": "guille-reg-aloc-jit.png",
    "supervisors": [
      "Guillermo Polito",
      "Nahuel Palumbo"
    ],
    "description": "The JIT compiler in the Pharo VM uses an Abstract Interpreter to translate Pharo methods into machine code. This interpreter applies optimizations to minimize stack access during register allocation.\n\nCurrently, the implementation maintains a single abstract state per method, even across branches. As a result, the JIT compiler must handle this constraint explicitly, leading to complex and hard-to-understand code when managing control flow merges.\n\nThis project aims to extend the register allocation mechanism to support multiple abstract states, enabling better handling of control flow merge points and improving both code clarity and performance.",
    "goal": "Expand the register allocation strategy to effectively manage multiple abstract states at control flow merge points, simplifying JIT compilation and improving optimization potential.",
    "keywords": [
      "jit compiler",
      "register allocation",
      "abstract interpretation"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Refactoring",
        "OOP"
      ],
      "preferred": [
        "Compilers"
      ]
    }
  },
  {
    "id": "slang-separate",
    "title": "Enhance Slang with Separate Compilation",
    "img": "guille-slang-separate.png",
    "supervisors": [
      "Guillermo Polito",
      "Nahuel Palumbo"
    ],
    "description": "Slang is a framework for writing Virtual Machines in Smalltalk and compiling them to C for performance reasons. It translates selected Smalltalk classes and methods into C code.\n\nCurrently, the generated C code is merged into a few large files, making it difficult to read and manage. This project aims to introduce separate compilation by generating multiple C files—potentially one per class or hierarchy—resulting in smaller, more modular, and more readable code.",
    "goal": "Implement separate compilation in Slang to generate multiple C files, improving readability, maintainability, and compilation efficiency.",
    "keywords": [
      "slang",
      "c code",
      "separate compilation"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Refactoring",
        "OOP",
        "C"
      ],
      "preferred": []
    }
  },
  {
    "id": "object-pointers",
    "title": "Eliminate Object Pointers in JIT-Compiled Code for Better GC Performance",
    "img": "guille-object-pointers.jpg",
    "supervisors": [
      "Guillermo Polito",
      "Nahuel Palumbo"
    ],
    "description": "In the Pharo VM, JIT compilation embeds object pointers directly into compiled machine code. These pointers must be visited during garbage collection to properly manage memory.\n\nCurrently, the Garbage Collector must traverse and disassemble the compiled machine code to locate these pointers, introducing a performance overhead. This project aims to modify both the JIT compiler and the Garbage Collector to use a separate structure—an object-pointer table—to store and access object references efficiently.",
    "goal": "Optimize garbage collection by removing object pointers from JIT-generated machine code. This includes:\n- Identifying where the JIT compiler embeds object pointers.\n- Modifying the JIT compiler to store object references in an object-pointer table instead of inline in the machine code.\n- Updating the Garbage Collector to traverse the object-pointer table instead of disassembling machine code.\n\nThis approach reduces GC overhead, improving performance and simplifying memory management in the Pharo VM.",
    "keywords": [
      "object pointers",
      "jit compiler",
      "garbage collection"
    ],
    "size": "Medium",
    "difficulty": "Hard",
    "skills": {
      "required": [
        "Refactoring",
        "OOP"
      ],
      "preferred": [
        "Compilers",
        "Garbage Collection"
      ]
    }
  },
  {
    "id": "microdown",
    "title": "Better support for web elements in Foliage/Microdown",
    "img": "MicrodownFoliage.jpg",
    "supervisors": [
      "Stéphane Ducasse"
    ],
    "description": "Improve the web support of Foliage and Microdown  [Foliage](https://github.com/Ducasse/Foliage) / [Microdown](https://github.com/pillar-markup/Microdown).",
    "goal": "The goal is to extend Microdown and Foliage to support new kinds of components for static websites deployed in Foliage. Examples are shown in the screenshot: list of book descriptions. Other examples are list of publication. Microdown is easily extensible because it has been designed for this kind of scenario.",
    "keywords": [
      "Document model",
      "Markup",
      "Web",
      "Static generation"
    ],
    "size": "Medium",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Communication skills",
        "OOP",
        "Pharo"
      ],
      "preferred": [
        "Visitor, Builder, and other patterns",
        "OO Design"
      ]
    }
  },
  {
    "id": "CforMoose",
    "title": "C support for Moose",
    "img": "Moose.jpg",
    "supervisors": [
      "Stéphane Ducasse",
      "Nicolas Anquetil"
    ],
    "description": "The idea is to define a Moose plugin to support the analysis of C code.",
    "goal": "The goal of the project is to extend the ![moose platform](https://modularmoose.org) to support C program analysis. The student will work on using a C Parser either SmaCC or TreeSitter. He will also define on a FAMIX metamodel definition for C. Then he will work on an importer (a program that given a C AST) will generate a FAMIX model for C. The student will work one CPP is applied to the code.",
    "keywords": [
      "Moose model",
      "C",
      "FAMIX",
      "Static analysis"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Communication skills",
        "OOP",
        "Pharo"
      ],
      "preferred": [
        "Visitor, Builder, and other patterns",
        "OO Design"
      ]
    }
  },
  {
    "id": "Pharo54",
    "title": "A DJ Application with Phausto and Bloc",
    "img": "pharo54.jpg",
    "supervisors": [
      "Domenico Cipriani",
      "Sebastian Jordan"
    ],
    "description": "Develop a DJ application in Pharo using Phausto for audio playback, filters, and effects, and Bloc for the user interface.",
    "goal": "Phausto is a Pharo library API that enables sound synthesis and digital signal processing (DSP) by embedding Faust. It can be used to play back audio files as well as to build audio filters and effects. By using Bloc to design the user interface, a modern DJ application can be developed, including features such as reading audio file metadata and organizing tracks into playlists. Additional features such as BPM detection, synchronization, and quantization can be implemented using Pharo core classes and methods.",
    "keywords": [
      "Pharo",
      "Phausto",
      "Bloc",
      "Music",
      "UX Design"
    ],
    "size": "Large",
    "difficulty": "Medium",
    "skills": {
      "required": [
        "Pharo"
      ],
      "preferred": [
        "Phausto",
        "Bloc",
        "Sound synthesis and DSP programming",
        "UX Design"
      ]
    }
  }
]